from pathlib import Path
from typing import Dict, List, Optional

from pydantic import BaseModel, Field
from ytsum.storage.common import BlobStorage

VIDEO_META_DATA_PREFIX = "metadata/videos/"
VIDEO_ARTIFACTS_PREFIX = "artifacts/"


class VideoMetadata(BaseModel):
    id: str
    title: Optional[str] = Field(default=None, description="The title of the video")
    description: Optional[str] = Field(default=None, description="The description of the video")
    url: Optional[str] = Field(default=None, description="The URL of the video")

    video_file_path: Optional[str] = Field(default=None, description="The path to the video file")
    audio_file_path: Optional[str] = Field(default=None, description="The path to the audio file")
    subtitle_file_paths: List[str] = Field(default_factory=list, description="The paths to the subtitle files")
    info_file_path: Optional[str] = Field(
        default=None,
        description="The path to the video info file (JSON) generated by youtube-dl",
    )
    artifact_paths: List[str] = Field(default_factory=list, description="The paths to all files related to the video")


class YoutubeDLVideoInfo(BaseModel):
    id: str = Field(..., description="The ID of the video")
    title: Optional[str] = Field(default=None, description="The title of the video")
    description: Optional[str] = Field(None, description="The description of the video")
    channel_id: Optional[str] = Field(None, description="The ID of the channel")
    channel_url: Optional[str] = Field(None, description="The URL of the channel")
    duration: Optional[int] = Field(None, description="The duration of the video")
    view_count: Optional[int] = Field(None, description="The view count of the video")
    fulltitle: Optional[str] = Field(None, description="The full title of the video")


class VideoRepository:
    def __init__(self, storage: BlobStorage) -> None:
        self._storage = storage

    async def start(self) -> None:
        self._storage.start()

    async def shutdown(self) -> None:
        self._storage.shutdown()

    async def find_all(self) -> List[VideoMetadata]:
        """
        Find all existing videos in the repository.

        Returns:
            List[str]: A list of paths.
        """

        result: List[VideoMetadata] = []
        async for path in self._storage.list_files(VIDEO_META_DATA_PREFIX):
            data = await self._storage.load_model(path=path, response_model=VideoMetadata)
            result.append(data)
        return result

    async def find_by_id(self, video_id: str) -> Optional[VideoMetadata]:
        """
        Find a video by its ID.

        Args:
            video_id (str): The ID of the video to find.

        Returns:
            Optional[VideoMetadata]: The video metadata if found, None otherwise.
        """
        path = f"{VIDEO_META_DATA_PREFIX}{video_id}.json"
        exists = await self._storage.exists(path=path)
        if exists:
            return await self._storage.load_model(path=path, response_model=VideoMetadata)

        return None

    async def upsert(self, video: VideoMetadata) -> None:
        """
        Create or update a video metadata.

        Args:
            video (VideoMetadata): The video metadata to upsert.
        """
        path = f"{VIDEO_META_DATA_PREFIX}{video.id}.json"
        await self._storage.save_model(path=path, model=video)

    async def upload_artifacts(self, video_id: str, local_file_paths: List[Path]) -> Dict[Path, str]:
        """
        Upload video artifacts in the local disk to the storage.

        Args:
            video_id (str): The ID of the video.
            local_file_paths (List[Path]): The paths to the local files to upload

        Returns:
            Dict[Path, str]: A dictionary mapping local file paths to their storage paths.
        """
        result: Dict[Path, str] = {}
        for local_file_path in local_file_paths:
            destination_path = f"{VIDEO_ARTIFACTS_PREFIX}{video_id}/{local_file_path.name}"
            await self._storage.save_file(src_file_path=local_file_path, destination_path=destination_path)
            result[local_file_path] = destination_path
        return result

    async def save_formatted_transcript(self, video_id: str, transcript: str) -> None:
        """
        Save the formatted transcript of a video.

        Args:
            video_id (str): The ID of the video.
            transcript (str): The formatted transcript.
        """
        path = f"{VIDEO_ARTIFACTS_PREFIX}{video_id}/formatted-transcript.txt"
        await self._storage.upload_blob(data=transcript, destination_path=path)

    async def has_formatted_transcript(self, video_id: str) -> bool:
        """
        Check if a video has a formatted transcript.

        Args:
            video_id (str): The ID of the video.

        Returns:
            bool: True if the video has a formatted transcript, False otherwise.
        """
        path = f"{VIDEO_ARTIFACTS_PREFIX}{video_id}/formatted-transcript.txt"
        return await self._storage.exists(path=path)
